# Docker
![](https://blog.codewithdan.com/wp-content/uploads/2023/06/Docker-Logo-1024x576.png)
## Чем отличается виртуализация от контейнеризации

### Что такое виртуализация

`Виртуализация` – это процесс, который позволяет компьютеру совместно использовать свои аппаратные ресурсы с несколькими средами, разделенными цифровым способом.

Виртуальная машина – это программно-определяемый компьютер, работающий на физическом компьютере с отдельной операционной системой и вычислительными ресурсами. Физический компьютер называется хост-машиной, а виртуальные машины – гостевыми машинами. Виртуальные машины абстрагируются от аппаратного обеспечения компьютера с помощью гипервизора.

Гипервизор – это программный компонент, управляющий несколькими виртуальными машинами на компьютере. Это гарантирует, что каждая виртуальная машина получает выделенные ресурсы и не мешает работе других виртуальных машин. Существует два типа гипервизоров.

Каждая виртуальная машина работает изолированно, как самый настоящий физический компьютер со своими ресурсами и уровнем производительности. Поэтому виртуализация требует хорошей производительности физического железа — чтобы полноценно эмулировать рабочее окружение операционной системы в ВМ.

`Виртуальная машина (ВМ) — абстракция на уровне физического оборудования, превращает один сервер в несколько.`

Гипервизор обеспечивает изолированную среду выполнения для каждой виртуальной машины, а также управляет доступом ВМ и гостевых ОС к аппаратным ресурсам физического сервера.

В классическом подходе гипервизоры группируются по двум типам: гипервизоры первого типа запускаются непосредственно на аппаратном обеспечении компьютера («железе»), а гипервизорам второго типа для работы необходимо наличие хостовой операционной системы. 

В последние несколько лет классическая классификация претерпевает изменения – добавился гибридный тип гипервизоров (тип 1.5), который сочетает характеристики первого и второго типов.

`Гипервизоры первого типа`

Гипервизоры первого типа показывают высокое быстродействие, однако обладают очевидным недостатком – необходимость поддерживать драйверы устройств приводит к сужению списка совместимого аппаратного обеспечения.

`Гипервизоры второго типа (hosted)`

Гипервизоры второго типа показывают меньшее относительно гипервизоров первого типа быстродействие и реже используются в промышленной эксплуатации, однако отлично подходят для задач обучения и разработки ПО.

### Что такое контейнеризация

Контейнеризация — это способ, при котором виртуальная среда запускается прямо из ядра хостовой
операционной системы (то есть мы не устанавливаем другую ОС). В данном случае изоляцию ОС и приложений
поддерживает контейнер. Он содержит специальный набор файлов, а также все зависимости запускаемого в нём
приложения: код, библиотеки, инструменты и настройки. Всё это упаковано в отдельный образ, работу которого запускает
движок (контейнерный движок), например, такой как Docker, CRI-O, Railcar и прочие.

`Контейнер — абстракция на уровне приложения, объединяет зависимости и код.`

![](https://www.itc.by/wp-content/uploads/virtualnye-mashiny-i-kontejnery.jpg)

### Плюсы

#### Виртуализация
- Высокий уровень изоляции
- Разнообразие ОС


#### Контейнеризация
- Легковесность
- Почти мгновенный старт
- Меньшие вычислительные потребности
- Переносимость
- Одноразовость

## Как работает контейнеризация
- `Изоляция`: Контейнеры используют механизмы ядра операционной системы (например, пространство пользователя Linux) для обеспечения изоляции приложения от окружения хост-системы и других контейнеров. Каждый контейнер имеет свое собственное файловое пространство, сетевые настройки, процессы и другие ресурсы.
- `Образ контейнера`: Для создания контейнера сначала необходимо создать образ контейнера. Образ контейнера содержит все необходимые файлы и зависимости для запуска приложения. Образ можно создать вручную или автоматически с помощью специальных инструментов.
- `Запуск контейнера`: Когда образ контейнера создан, он может быть запущен на любой поддерживаемой системе, где установлен соответствующий контейнерный движок (например, Docker). При запуске образа создается экземпляр контейнера, который работает в изолированной среде.
- `Портабельность`: Контейнеры обеспечивают высокую портабельность приложений. Поскольку контейнер содержит все необходимое для работы приложения, он может быть легко перемещен между различными средами, будь то разработка, тестирование или продакшн.
- `Управление ресурсами`: Контейнеры могут быть настроены для использования определенных ресурсов, таких как процессорное время, память и сетевые ресурсы, что позволяет эффективно управлять ресурсами и избегать конфликтов между контейнерами.
- `Масштабирование`: Контейнеры обеспечивают легкость в масштабировании приложений. Новые копии контейнера могут быть быстро созданы и масштабированы в зависимости от нагрузки.

## Что такое Docker

Docker — это платформа для разработки, запуска и управления контейнерами. Докер позволяет создавать контейнеры,
автоматизирует их запуск и управляет жизненным циклом.

Докер состоит из нескольких компонентов:

1. `Docker-host` (докер-хост)
Это компьютер, на котором работает докер: персональный компьютер, сервер или виртуальная машина в облаке.
2. `Docker-daemon` (докер-демон)
Это фоновый процесс (”душа докера”), который работает постоянно и ожидает команды. Все операции по управлению
контейнерами отправляются именно в демон. Например: запустить или остановить контейнер, скачать образ. И уже на
основе этих команд демон выполняет необходимые действия с контейнерами и образами. Поэтому докер-демон знает
все о контейнерах, запущенных на одном хосте: сколько всего контейнеров, какие из них работают, где хранятся образы
и так далее.
3. `Docker-client` (докер-клиент)
Это клиент, при помощи которого пользователи взаимодействуют с демоном и отправляют ему команды. Это может
быть консоль, API или графический интерфейс. То есть это то, через что мы отправляем запросы докер-демону.
4. `Docker-image` (докер-образ)
Это неизменяемый образ, из которого разворачивается контейнер. Его можно рассматривать как набор файлов, необходимых для запуска и работы приложения на другом хосте. Аналогия из мира установки ПО: образ — это компакт-диск, с которого устанавливается программа.
5. `Docker-container` (докер-контейнер)
Это уже развернутое (на основе образа) и запущенное приложение. Продолжая аналогию с установкой ПО, контейнер
можно сравнить с уже установленной и работающей программой на ПК (которую установили с диска - образа).
6. `Dockerfile` (докер-файл) Это файл-инструкция для сборки образа.
7. `Docker registry` Это репозиторий (место), в котором хранятся образы. Когда разработчики создают приложения, они размещают свои
образы в этих репозиториях, откуда их могут скачать другие люди. Есть публичные репозитории, например, Docker Hub.
Можно создать свой закрытый репозиторий, для использования внутри компании или команды. Это своего рода GitHub,
только на котором хранится не программный код, докер-образы.
На Docker Hub собраны образы множества популярных программ или платформ: базы данных, веб-серверы,
компиляторы, операционные системы и так далее.

![](https://www.pngfind.com/pngs/m/385-3851598_as-you-can-see-docker-client-and-docker.png)

## Обзор сетей

Контейнерная сеть подразумевает возможность контейнеров подключаться и взаимодействовать друг с другом или с рабочими нагрузками, не относящимися к Docker.

Контейнеры имеют включенную сеть по умолчанию, и они могут устанавливать исходящие соединения. Контейнер не имеет информации о том, к какому типу сети он подключен, или являются ли его одноранговые узлы также рабочими нагрузками Docker или нет. Контейнер видит только сетевой интерфейс с IP-адресом, шлюзом, таблицей маршрутизации, службами DNS и другими сетевыми данными. То есть, если контейнер не использует сетевой noneдрайвер.

### Драйверы

- `bridge` - Сетевой драйвер по умолчанию. При создании контейнера Docker автоматически присваивает ему IP-адрес из виртуальной сети bridge. Контейнеры в этой сети могут связываться друг с другом по именам контейнеров.
- `host` - Удалите сетевую изоляцию между контейнером и хостом Docker. Контейнер использует сетевые интерфейсы хоста напрямую, обеспечивая высокую производительность коммуникаций.
- `none` - Полностью изолируйте контейнер от хозяина и других контейнеров. Контейнер не имеет сетевого интерфейса. Это изолирует контейнер от всех сетевых подключений.
- `overlay` - Оверлейные сети объединяют несколько демонов Docker. Позволяет создавать сети, которые могут распространяться на несколько хостов Docker, что обеспечивает коммуникацию между контейнерами на разных хостах.
- `ipvlan` - Сети IPvlan обеспечивают полный контроль над адресацией IPv4 и IPv6. Сеть ipvlan в Docker представляет собой тип сетевой модели, который позволяет контейнерам обмениваться данными напрямую с внешней сетью, минуя виртуальный маршрутизатор Linux. 
- `macvlan` - Назначьте MAC-адрес контейнеру. озволяет контейнерам иметь свои собственные MAC-адреса и связанные сетевые интерфейсы, что делает их более подобными виртуальным машинам.

## Слои, кеширование и оптимизации

Большинство Docker-образов содержащих готовые приложения, весят от сотен мегабайт до нескольких гигабайт. Это значит, что стартуя контейнер, вся эта файловая система должна копироваться куда-то, чтобы с ней можно было работать, добавлять, изменять и удалять файлы. Старт контейнера, в таком случае, мог бы занимать десятки секунд и даже минуты. Однако, этого не происходит. Docker значительно оптимизирует эту часть работы за счет использования файловой системы OverlayFS.

Принцип ее работы следующий. OverlayFS работает не с единой файловой структурой, а c частями, которые называются слоями. Каждый слой, это набор файлов и директорий, получающийся в результате выполнения команды RUN и ей подобных внутри Dockerfile. Затем слои виртуально сливаются в одну структуру, создавая внешнее впечатление что все эти директории и файлы находятся в одном месте.

Слои в итоговом образе создают только инструкции FROM, RUN, COPY, и ADD. Другие инструкции что-то настраивают, описывают метаданные, или сообщают Docker о том, что во время выполнения контейнера нужно что-то сделать, например — открыть какой-то порт или выполнить какую-то команду.

## Dockerfile
`Dockerfile` — это инструкция для сборки образа. Это простой текстовый файл, содержащий по одной команде в каждой
строке. В нем указываются все программы, зависимости, образы, и команды которые нужны для создания контейнера.
То есть это файл с построчным перечислением необходимых компонентов и последовательности действий, которые надо
совершить. 

- `FROM` — задаёт базовый (родительский) образ.
- `LABEL` — описывает метаданные. Например — сведения о том, кто создал и поддерживает образ.
- `ENV` — устанавливает постоянные переменные среды.
- `RUN` — выполняет команду и создаёт слой образа. Используется для установки в контейнер пакетов.
- `COPY` — копирует в контейнер файлы и папки.
- `ADD` — копирует файлы и папки в контейнер, может распаковывать локальные .tar-файлы.
- `CMD` — описывает команду с аргументами, которую нужно выполнить когда контейнер будет запущен. Аргументы могут быть переопределены при запуске контейнера. В файле может присутствовать лишь одна инструкция CMD.
- `WORKDIR` — задаёт рабочую директорию для следующей инструкции.
- `ARG` — задаёт переменные для передачи Docker во время сборки образа.
- `ENTRYPOINT` — предоставляет команду с аргументами для вызова во время выполнения контейнера. Аргументы не переопределяются.
- `EXPOSE` — указывает на необходимость открыть порт.
- `VOLUME` — создаёт точку монтирования для работы с постоянным хранилищем.

## Volumes

### Постоянное хранение данных
Существуют два способа, позволяющих сделать срок жизни данных большим срока жизни контейнера. Один из способов заключается в использовании технологии bind mount. При таком подходе к контейнеру можно примонтировать, например, реально существующую папку. Работать с данными, хранящимися в такой папке, смогут и процессы, находящиеся за пределами Docker. Вот как выглядят монтирование tmpfs и технология bind mount.

![](https://habrastorage.org/r/w1560/getpro/habr/post_images/29c/1ea/9a4/29c1ea9a4546930dd8d03c7c5f521cc8.png)

Минусы использования технологии bind mount заключаются в том, что её использование усложняет резервное копирование данных, миграцию данных, совместное использование данных несколькими контейнерами. Гораздо лучше для постоянного хранения данных использовать тома Docker.

### Тома

Том — это файловая система, которая расположена на хост-машине за пределами контейнеров. Созданием и управлением томами занимается Docker. Вот основные свойства томов Docker:

- Они представляют собой средства для постоянного хранения информации.
- Они самостоятельны и отделены от контейнеров.
Ими могут совместно пользоваться разные контейнеры.
- Они позволяют организовать эффективное чтение и запись данных.
- Тома можно размещать на ресурсах удалённого облачного провайдера.
- Их можно шифровать.
- Им можно давать имена.
- Контейнер может организовать заблаговременное наполнение тома данными.
- Они удобны для тестирования.

## Docker Compose
Docker-compose - инструмент, который позволяет разворачивать и настраивать несколько контейнеров одновременно.
Например, для веб-приложения нужно развернуть стек LAMP: Linux, Apache, MySQL, PHP. Каждое из приложений — это
отдельный контейнер. Но в этой ситуации нам нужны именно все контейнеры вместе, а не отдельно взятое приложение.
Docker-compose позволяет развернуть и настроить все приложения одной командой, а без него пришлось разворачивать и
настраивать каждый контейнер отдельно.

## Best Practices
### Используйте многоэтапные сборки
Многоэтапные сборки позволяют уменьшить размер вашего конечного образа, создавая более четкое разделение между сборкой вашего образа и конечным выводом. Разделите ваши инструкции Dockerfile на отдельные этапы, чтобы быть уверенным, что конечный вывод содержит только файлы, необходимые для запуска приложения.

Использование нескольких этапов также может позволить вам более эффективно выполнять сборку, выполняя этапы сборки параллельно.

### Выберите правильное базовое изображение
Первый шаг к достижению безопасного образа — выбор правильного базового образа. При выборе образа убедитесь, что он создан из надежного источника и имеет небольшой размер.

При выборе базового изображения обратите внимание на значки, указывающие на то, что изображение является частью этих программ.

При создании собственного образа из Dockerfile убедитесь, что вы выбрали минимальный базовый образ, который соответствует вашим требованиям. Меньший базовый образ не только обеспечивает переносимость и быструю загрузку, но также уменьшает размер вашего образа и минимизирует количество уязвимостей, возникающих из-за зависимостей.

Вам также следует рассмотреть возможность использования двух типов базового образа: один для сборки и модульного тестирования, а другой (обычно более тонкий) образ для производства. На более поздних этапах разработки вашему образу могут не потребоваться инструменты сборки, такие как компиляторы, системы сборки и инструменты отладки. Небольшой образ с минимальными зависимостями может значительно снизить поверхность атаки.

### Чаще перестраивайте свои изображения

Образы Docker неизменяемы. Создание образа — это моментальный снимок образа на данный момент. Это включает в себя любые базовые образы, библиотеки или другое программное обеспечение, которое вы используете в своей сборке. Чтобы поддерживать образы в актуальном состоянии и безопасности, обязательно пересоздавайте образ часто, с обновленными зависимостями.

Чтобы быть уверенным, что вы получаете последние версии зависимостей в своей сборке, вы можете использовать `--no-cache` опцию предотвращения попаданий в кэш.

### Исключить с помощью .dockerignore
Чтобы исключить файлы, не имеющие отношения к сборке, без реструктуризации исходного репозитория, используйте .dockerignoreфайл. Этот файл поддерживает шаблоны исключения, аналогичные .gitignoreфайлам.

Например, чтобы исключить все файлы с .md расширением:

```
*.md
```

### Создавайте эфемерные контейнеры
Образ, определенный вашим Dockerfile, должен генерировать контейнеры, которые являются настолько эфемерными, насколько это возможно. Эфемерность означает, что контейнер может быть остановлен и уничтожен, а затем перестроен и заменен с абсолютно минимальной настройкой и конфигурацией.

### Не устанавливайте ненужные пакеты

### Разделить приложения
Каждый контейнер должен иметь только одну заботу. Разделение приложений на несколько контейнеров упрощает горизонтальное масштабирование и повторное использование контейнеров. Например, стек веб-приложений может состоять из трех отдельных контейнеров, каждый со своим собственным уникальным образом, для управления веб-приложением, базой данных и кэшем в памяти в разделенной манере.

Ограничение каждого контейнера одним процессом — хорошее эмпирическое правило, но это не жесткое и быстрое правило.

### Сортировка многострочных аргументов

По возможности сортируйте многострочные аргументы в алфавитно-цифровом порядке, чтобы упростить обслуживание. Это помогает избежать дублирования пакетов и значительно упрощает обновление списка. Это также значительно упрощает чтение и просмотр PR. Добавление пробела перед обратной косой чертой ( \) также помогает.

### Использовать кэш сборки
При сборке образа Docker проходит по инструкциям в вашем Dockerfile, выполняя каждую в указанном порядке. Для каждой инструкции Docker проверяет, может ли он повторно использовать инструкцию из кэша сборки.

Понимание того, как работает кэш сборки и как происходит аннулирование кэша, имеет решающее значение для обеспечения более быстрых сборок. 
### Версии базовых изображений Pin
Теги изображений изменяемы, то есть издатель может обновить тег, чтобы он указывал на новое изображение. Это полезно, поскольку позволяет издателям обновлять теги, чтобы они указывали на более новые версии изображения. И как потребитель изображения, это означает, что вы автоматически получаете новую версию, когда перестраиваете свое изображение.

Например, если вы укажете `FROM alpine:3.19` в своем Dockerfile, `3.19` то будет установлена ​​последняя версия патча для `3.19`.

### Создавайте и тестируйте свои образы в CI
При внесении изменений в систему управления исходным кодом или создании запроса на извлечение используйте GitHub Actions или другой конвейер CI/CD для автоматического создания и тегирования образа Docker, а также его тестирования.

## Namespaces и CGroups
![](https://miro.medium.com/v2/resize:fit:640/format:webp/0*ktslXG-epHCuKj-5.png)

Docker использует пространства имен для предоставления изолированного рабочего пространства, называемого контейнером. Когда вы запускаете контейнер, Docker создает набор пространств имен для этого контейнера.

Это означает, что каждый контейнер имеет собственное изолированное пространство имен для процессов, сети, точек монтирования и многого другого.
### Namespace

#### PID namespace (идентификаторы процессов):

- Изолирует процессы контейнера от хостовой системы и других контейнеров.
- Контейнер видит только свои процессы.
- Например, процесс с PID 1 в контейнере — это основной процесс контейнера, но на хосте у него будет другой PID.

#### NET namespace (сеть):

- Изолирует сетевые интерфейсы и маршрутизацию.
- Каждый контейнер имеет собственные виртуальные сетевые интерфейсы (veth) и сетевую конфигурацию.
- Например, один контейнер может быть подключен к одной сети, а другой к другой.

#### MNT namespace (точки монтирования):

- Изолирует файловую систему контейнера.
- Контейнер видит только свои точки монтирования и не имеет доступа к файловым системам хостовой системы или других контейнеров.

#### UTS namespace (имя хоста):

- Изолирует настройки имени хоста и доменного имени.
- Каждый контейнер может иметь своё собственное имя хоста.
#### IPC namespace (межпроцессное взаимодействие):

- Изолирует механизмы межпроцессного взаимодействия, такие как семафоры и разделяемая память.

#### User namespace (пользователи):
- Позволяет контейнеру иметь собственные идентификаторы пользователей (UID/GID).
- Например, внутри контейнера пользователь с UID 0 (root) может быть отображён на пользователя с меньшими привилегиями на хосте.


### Cgroups (контрольные группы)
Cgroups используются для управления ресурсами, выделяемыми контейнерам. Это позволяет Docker ограничивать ресурсы, чтобы один контейнер не мог использовать их больше, чем разрешено, и не мешал другим контейнерам.

## Как Docker использует namespaces и cgroups?
`Namespaces` обеспечивают изоляцию, позволяя каждому контейнеру работать как отдельной "мини-ОС".

`Cgroups` управляют ресурсами, выделяемыми контейнерам, гарантируя, что они не превышают заданных лимитов и не мешают друг другу. 

## Через что ходит трафик docker 
В Docker виртуальные интерфейсы представляют собой сетевые компоненты, которые обеспечивают взаимодействие между контейнерами, хостом и внешними сетями. Эти интерфейсы реализуются на уровне сетевого стека и упрощают управление сетями в контейнеризированной среде.

По умолчанию есть interface: `docker0`.

| Component	| Virtual Interface | Purpose |
| --- | --- | --- |
| Bridge Networks | docker0, veth pairs	| Связь между контейнерами по умолчанию. |
| Overlay Networks | VXLAN tunnels, veth pairs	| Связь контейнеров между узлами. |
| Macvlan Networks | Sub-interfaces on host NIC | Прямая интеграция контейнеров с физической сетью. |
| Host Network Mode | Host NICs directly shared | Контейнер использует сетевой стек хоста. |
| Ingress Network | Virtual interfaces per node | Маршрутизация трафика и связь между контейнерами. |