# Linux Architecture
## Что такое процесс в linux
Процесс в Linux (как и в UNIX) - это программа, которая выполняется в отдельном виртуальном адресном пространстве. Когда пользователь регистрируется в системе, автоматически создается процесс, в котором выполняется оболочка (shell), например, /bin/bash.

## Состояния процессов
- **R**: Running/Runnable — процесс выполняется или готов к выполнению.
- **S**: Sleeping — процесс не выполняется, не потребляет процессорное время, ожидает события (например, ввода/вывода).
- **D**: Uninterruptible Sleep — процесс спит и не может быть прерван сигналами(занимается вводом/выводом)
- **Z**: Zombie — процесс завершен, но его родительский процесс еще не прочитал его статус.
- **T**: Stopped — процесс остановлен (например, получил сигнал).
- X: Terminated — еще не удален из таблицы процессов

## Что такое inode
Inode (индексный узел) - это структура данных в файловой системе в стиле Unix,
которая описывает объект файловой системы, такой как файл или каталог.
Каждый инод хранит атрибуты и расположение (места) дискового блока данных
объекта. Атрибуты объектов файловой системы могут включать метаданные
(время последнего изменения, доступа, модификации), а также данные о
владельце и разрешениях.

### Основные характеристики inodes:

1. **Метаданные**: Inode хранит информацию о файле, такую как:
    - Права доступа (чтение, запись, выполнение).
    - Владелец и группа.
    - Размер файла.
    - Дата и время создания, изменения и доступа.
    - Указатели на данные (адреса блоков на диске, где хранится содержимое файла).
2. **Отделение данных от имени файла**: Inode позволяет файловой системе отделять метаданные файла от его имени. Это означает, что имя файла, которое вы видите, не хранится в inode, а находится в специальной структуре, связанной с inode.
3. **Уникальность**: Каждый inode в файловой системе имеет уникальный номер (inode number), который используется для идентификации файла или директории.
4. **Количество inodes**: При создании файловой системы устанавливается ограниченное количество inodes. Если все inodes заняты, вы не сможете создать новые файлы, даже если на диске достаточно свободного пространства.

## IPtables
Iptables работает путем проверки пакетов данных на соответствие определенным критериям и выполнения заданных действий, если пакеты соответствуют этим критериям. Эти критерии и действия определяются в таблицах, которые состоят из набора правил.

В Iptables есть четыре основные таблицы:

1. **raw** - предназначена для обработки пакетов прежде, чем они будут переданы системе conntrack, которая занимается отслеживанием состояния соединений и принадлежностью пакетов этим соединениям. Содержит встроенные цепочки PREROUTING и OUTPUT.
2. **mangle** - используется для модификации некоторых заголовков (TTL, TOS) и маркировке пакетов и соединений, содержит цепочки PREROUTING, INPUT, FORWARD, OUTPUT и POSTROUTING.
3. **nat** - предназначен для преобразования адресов и портов источника и назначения пакетов, встроенные цепочки: PREROUTING, OUTPUT, POSTROUTING.
4. **filter** - применяется, собственно, для фильтрации пакетов, является таблицей по умолчанию, т.е. если таблица не указана явно, то используется filter, имеет цепочки INPUT, FORWARD и OUTPUT.
5. **security** - используется для работы совместно с системами принудительного контроля доступа, такими как SELinux. Встроенные цепочки INPUT, FORWARD, OUTPUT.

Каждая таблица состоит из набора цепочек. Цепочки - это последовательности правил, которые применяются к пакетам. В Iptables есть три встроенные цепочки:

1. **PREROUTING** - используется для всего входящего трафика до принятия первого решения о маршрутизации
2. **INPUT** - применяется для входящего трафика текущего узла
3. **FORWARD** - через нее проходит транзитный трафик узла
4. **OUTPUT** - применятся для исходящего трафика текущего узла
5. **POSTROUTING** - используется для всего исходящего трафика после принятия всех решений о маршрутизации

## UFW

UFW (Uncomplicated Firewall) — удобный интерфейс для управления политиками безопасности [межсетевого экрана.](http://help.ubuntu.ru/wiki/firewall) Наши серверы постоянно подвергаются различным атакам или сканируются в поиске уязвимостей. Как только эти уязвимости находятся, мы рискуем стать частью ботнета, раскрыть конфиденциальные данные или потерять деньги из-за сбоев в работе веб-приложений. Одной из первых мер по снижению рисков безопасности является грамотная настройка правил межсетевого экрана. В нашем руководстве мы рассмотрим основные команды и правила работы с утилитой UFW.

### Основные характеристики UFW:

1. **Простота использования**: UFW предоставляет удобный интерфейс командной строки для управления правилами брандмауэра, что делает его подходящим для пользователей, не обладающих глубокими знаниями о сетевой безопасности.
2. **Стандартные настройки**: UFW позволяет легко включать и выключать брандмауэр, а также добавлять или удалять правила для разрешения или блокировки трафика.
3. **Поддержка профилей**: UFW поддерживает создание и использование профилей для приложений, что позволяет быстро применять правила к целым приложениям, например, к веб-серверу или SSH.
4. **Логирование**: UFW может вести журналы событий, что позволяет отслеживать, какие подключения были разрешены или заблокированы.
5. **Интеграция с `iptables`**: UFW работает на основе `iptables`, что позволяет ему использовать мощные возможности фильтрации, предоставляемые этой системой.

### Примеры команд UFW

- **Включение UFW**:
    
    ```bash
    sudo ufw enable
    
    ```
    
- **Выключение UFW**:
    
    ```bash
    sudo ufw disable
    
    ```
    
- **Разрешение порта (например, 22 для SSH)**:
    
    ```bash
    sudo ufw allow 22
    
    ```
    
- **Блокировка порта (например, 23 для Telnet)**:
    
    ```bash
    sudo ufw deny 23
    
    ```
    
- **Просмотр статуса UFW и правил**:

```bash
sudo ufw status
```

## Сигналы linux

Сигналы в Linux — это механизм межпроцессного взаимодействия, который позволяет процессам отправлять уведомления друг другу о различных событиях. Сигналы могут использоваться для управления процессами, обработки ошибок и информирования о состоянии системы.

### Примеры сигналов

- **`SIGINT`**: Сигнал прерывания, обычно отправляется при нажатии `Ctrl+C`. По умолчанию завершает процесс.
- **`SIGTERM`**: Сигнал завершения, который можно использовать для корректного завершения процесса.
- **`SIGKILL`**: Сигнал, который немедленно завершает процесс. Этот сигнал не может быть обработан или игнорирован.
- **`SIGSTOP`**: Сигнал, который приостанавливает выполнение процесса. Можно возобновить с помощью `SIGCONT`.

### Больше

1. **`SIGHUP` (1)**:
    - **Назначение**: Сигнал "повешенного соединения". Обычно отправляется, когда терминал, связанный с процессом, закрыт.
    - **Поведение**: По умолчанию завершает процесс, но часто используется для перезагрузки конфигурации.
2. **`SIGINT` (2)**:
    - **Назначение**: Сигнал прерывания. Отправляется, когда пользователь нажимает `Ctrl+C`.
    - **Поведение**: Завершает процесс.
3. **`SIGQUIT` (3)**:
    - **Назначение**: Сигнал завершения с дампом. Пользователь может отправить его с помощью `Ctrl+\`.
    - **Поведение**: Завершает процесс и создает дамп памяти.
4. **`SIGILL` (4)**:
    - **Назначение**: Сигнал "недопустимая инструкция". Отправляется, когда процесс пытается выполнить недопустимую инструкцию.
    - **Поведение**: Завершает процесс.
5. **`SIGABRT` (6)**:
    - **Назначение**: Сигнал аварийного завершения. Обычно отправляется функцией `abort()`.
    - **Поведение**: Завершает процесс и создает дамп памяти.
6. **`SIGFPE` (8)**:
    - **Назначение**: Сигнал арифметической ошибки (например, деление на ноль).
    - **Поведение**: Завершает процесс.
7. **`SIGKILL` (9)**:
    - **Назначение**: Сигнал немедленного завершения.
    - **Поведение**: Завершает процесс. Этот сигнал не может быть обработан или игнорирован.
8. **`SIGSEGV` (11)**:
    - **Назначение**: Сигнал сегментации. Возникает при попытке доступа к недопустимой области памяти.
    - **Поведение**: Завершает процесс.
9. **`SIGTERM` (15)**:
    - **Назначение**: Сигнал завершения. Обычно используется для корректного завершения процесса.
    - **Поведение**: Процесс может обработать этот сигнал.
10. **`SIGSTOP` (19)**:
    - **Назначение**: Сигнал приостановки выполнения процесса.
    - **Поведение**: Процесс останавливается и не может быть обработан или игнорирован.
11. **`SIGCONT` (18)**:
    - **Назначение**: Сигнал продолжения выполнения процесса, который был приостановлен.
    - **Поведение**: Возобновляет выполнение процесса.
12. **`SIGUSR1` и `SIGUSR2` (10 и 12)**:
    - **Назначение**: Пользовательские сигналы, которые могут быть использованы для специфических нужд приложений.
    - **Поведение**: Процесс может определить, как обработать эти сигналы.

## **Файловые системы в Linux**

**Файловая система Linux организована в форме иерархической структуры, которую образно можно представить в виде дерева. Она содержит в себе каталоги и подкаталоги, образуя таким образом вложенную структуру. Все файлы и каталоги начинаются от корневого каталога, который обозначается символом “/”, а далее распределяются по отдельным ветвям и листьям этого дерева. Таким образом создается логическая и удобная организация данных.**

**Linux придерживается стандартов иерархии файловой системы (Filesystem Hierarchy Standard, FHS). Эти стандарты определяют основные правила организации и содержания каталогов в системах, аналогичных UNIX. Они обеспечивают единообразие в структуре файловой системы, делая работу с разными дистрибутивами более предсказуемой и понятной для пользователей и разработчиков.**

**FHS определяет такие ключевые каталоги:**

- **/bin** для исполняемых файлов;
- **/home** содержит личные папки пользователей, предоставляя каждому свое пространство для файлов;
- **/etc** служит для размещения настроек и конфигурационных файлов системы;
- **/var** для переменных данных, среди прочих.

### Основные файловые системы для Linux:

- **Ext (Extended File System)**: Первая система, созданная для Linux. Улучшила производительность и функции.
- **Ext2**: Улучшение ext с поддержкой больших файлов, но без журналирования. Подходит для устройств без высокого требования к надежности.
- **Ext3**: Добавлено журналирование, повысившее надежность и уменьшившее время восстановления после сбоев.
- **Ext4**: Современная версия с улучшенной производительностью, поддержкой больших хранилищ и рядом технических усовершенствований.
- **XFS**: Масштабируемая и производительная система от SGI, популярна на серверах и для работы с большими данными.
- **JFS**: Разработана IBM, обеспечивает стабильность и эффективность при высоких нагрузках.
- **Btrfs**: Создана Oracle, обеспечивает гибкость, отказоустойчивость, проверку данных и сжатие.
- **Swap**: Используется для виртуальной памяти при нехватке RAM. Не является файловой системой в классическом понимании.