# Linux Base Commands
## Как узнать ip address по домену
- nslookup - отображает информацию о сайте по его домену
- ping - используется для проверки доступности устройства в сети и измерения времени, необходимого для передачи пакета данных туда и обратно. Она отправляет ICMP-эхо-запросы на указанный хост и ожидает ответов.
- traceroute - пользуется для отслеживания маршрута, который пакеты данных следуют от исходного узла до целевого узла.
## Определить маршрут следования пакета от инстанса до сайта
```bash
traceroute google.com
traceroute to google.com (142.250.203.142), 64 hops max
  1   192.168.100.1  0,710ms  0,572ms  0,472ms 
  2   37.45.128.1  3,691ms  3,524ms  2,969ms 
  3   93.84.80.53  5,316ms  3,453ms  4,366ms 
  4   93.85.80.57  3,104ms  7,842ms  8,023ms 
  5   178.124.190.132  2,542ms  2,427ms  2,734ms 
  6   178.124.190.128  10,853ms  7,502ms  2,661ms 
  7   93.85.80.229  3,364ms  2,721ms  2,750ms 
  8   74.125.146.96  14,175ms  13,097ms  13,230ms 
  9   142.251.225.169  13,203ms  11,058ms  11,263ms 
 10   209.85.253.225  11,257ms  10,834ms  10,200ms 
 11   142.250.203.142  11,018ms  10,056ms  10,001ms 
```
## Определить какие порты используются процессами
Чтобы узнать, какие порты используются процессами в Linux, вы можете воспользоваться несколькими командами:
1. `netstat` (если доступен):
```bash
netstat -tuln
```
- `t` — показывает TCP-порты.
- `u` — показывает UDP-порты.
- `l` — показывает только прослушиваемые порты.
- `n` — отображает адреса и порты в числовом формате.

2. `ss`:
```bash
ss -tuln
```
Это более современная альтернатива netstat, которая быстрее и предоставляет аналогичную информацию.

3. `lsof`:
```bash
lsof -i -n -P
```
- `i` — показывает открытые сетевые соединения.
- `n` — не преобразует адреса в имена.
- `P` — не преобразует номера портов в имена сервисов.

## Вывод команды ps auxft
Настройки:
- **`a`**: показывает процессы всех пользователей.
- **`u`**: выводит информацию с указанием пользователя.
- **`x`**: показывает процессы, не привязанные к терминалу.
- **`f`**: отображает дерево процессов, показывая иерархию.
- **`t`**: добавляет информацию о терминалах- 

Вывод:
- USER: владелец процесса
- PID: идентификатор процесса
- %CPU: использование CPU
- %MEM: использование памяти
- VSZ(Virtual size): память, которую выделили процессу, но не факт что он успел в эту память что-то записать.
- RSS(resident set size): это память, которую процесс занял, то есть что-то сохранил в виртуальную память
- TTY: терминал, связанный с процессом
- STAT: состояние процесса
- START: время старта процесса
- TIME: общее время процессорного времени
- COMMAND: команда, запустившая процесс## Вывод команды top

## Вывод команды top
Этот вывод, скорее всего, относится к мониторингу системы, например, из утилиты **`htop`** или **`top`** в Linux. Расшифруем детали по частям:

### Общая информация о процессах:

- **Tasks**: Общее количество процессов — **463**, из которых:
    - **1 running**: Активный (выполняющийся) процесс.
    - **459 sleeping**: Спящие процессы (ожидающие ресурсы или события).
    - **0 stopped**: Процессы, временно остановленные пользователем.
    - **3 zombie**: Зомби-процессы, которые завершили выполнение, но ещё не освобождены из списка процессов (плохая практика; стоит освободить их).

## Определить процессы которые имеют открытые файлы в директории /var/log
```bash
lsof +D /var/log
lsof | grep /var/log
```
### Объяснение столбцов вывода

1. **COMMAND**: Имя процесса, который открыл файл (например, `bash`, `syslogd`).
2. **PID**: Идентификатор процесса. Уникальный номер, присвоенный каждому запущенному процессу.
3. **USER**: Имя пользователя, под которым запущен процесс.
4. **FD**: Файловый дескриптор, который указывает, как процесс использует файл:
    - `cwd`: текущая рабочая директория.
    - `txt`: исполняемый файл.
    - `REG`: обычный файл.
    - `u`: дескриптор, открытый для чтения и записи.
5. **TYPE**: Тип файла:
    - `DIR`: директория.
    - `REG`: обычный файл.
    - `CHR`: символьный файл.
    - `FIFO`: именованный канал.
    - `SOCK`: сокет.
6. **DEVICE**: Устройство, на котором расположен файл (выражается в виде пары чисел).
7. **SIZE/OFF**: Размер файла или смещение в байтах, если это применимо.
8. **NODE**: Номер узла (inode) файла в файловой системе.
9. **NAME**: Полный путь к файлу или директории.

## Показать сколько места занято на дисках, показать сколько места на диске занимает директория /var/log/. Аналогично показать сколько занято inodes на дисках и в директории /var/log/; 
Вот команды, которые помогут вам получить информацию о занятом месте на дисках и inodes как для всей файловой системы, так и для директории /var/log.
1. Проверка занятого места на дисках
 
    Чтобы показать, сколько места занято на дисках, используйте команду `df`:
```bash
df -h
```
Объяснение:

- **`h`**: выводит информацию в удобочитаемом формате (например, гигабайты).

2. Проверка занятого места в директории `/var/log`

    Чтобы узнать, сколько места занимает директория `/var/log`, выполните команду:
```bash
du -sh /var/log
```

Объяснение:

- **`s`**: выводит только общий размер.
- **`h`**: выводит результат в удобочитаемом формате.

3. Проверка занятого пространства inodes на дисках

    Чтобы показать использование inodes на дисках, используйте:
```bash
df -i
```

Объяснение:

- **`i`**: показывает информацию о inodes.

### 4. Проверка использования inodes в директории `/var/log`.

    Чтобы узнать, сколько inodes используется в директории `/var/log`, выполните:
```bash
find /var/log | wc -l
```

Объяснение:

- **`find /var/log`**: находит все файлы и директории в `/var/log`.
- **`wc -l`**: подсчитывает количество строк, что соответствует количеству inodes.

## Показать дочерние процессы процесса PID 1
```bash
pstree -p 1
```
